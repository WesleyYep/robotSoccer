

FUNCTION_BLOCK selfMade	// Block definition (there may be more than one block per file)

VAR_INPUT				// Define input variables
	targetDist : REAL;
	targetTheta: REAL;
END_VAR

VAR_OUTPUT				// Define output variable
	linearVelocity: REAL;
	angularVelocity: REAL;
END_VAR

FUZZIFY targetDist
	TERM close := trian -73.2 0 50;
	TERM middle := trian 25 50 75;
	TERM far := trape 75 125 412 412;
END_FUZZIFY

FUZZIFY targetTheta
	TERM behindLeft := trian -540 -180 -100;
	TERM sideLeft := trian -135 -80 -25;
	TERM frontLeft := trian -45 -30 0;
	TERM straight := trian -5 0 5;
	TERM frontRight := trian 0 30 45;
	TERM sideRight := trian 25 80 135;
	TERM behindRight := trian 100 180 540;
END_FUZZIFY 

DEFUZZIFY linearVelocity
	TERM slow := trian -0.65 0 1.35;
	TERM medium := trian 0 1 2;
	TERM fast := trian 1 2 3;
	METHOD : COG;
	DEFAULT :=0;
END_DEFUZZIFY

DEFUZZIFY angularVelocity
	TERM LR := trian -19 -12 -5;
	TERM MR := trian -7 -5 -1;
	TERM SR := trian -2 -1 0;
	TERM zero := trian -1 0 1;
	TERM SL := trian 0 1 2;
	TERM ML := trian 1 5 7;
	TERM LL := trian 5 12 19;
	METHOD : COG;
	DEFAULT :=0;
END_DEFUZZIFY


RULEBLOCK No1
	AND : MIN;			// Use 'min' for 'and' (also implicit use 'max' for 'or' to fulfill DeMorgan's Law)
	ACT : MIN;			// Use 'min' activation method
	ACCU : MAX;			// Use 'max' accumulation method

	//RULE 1 : IF service IS poor OR food IS rancid THEN tip IS cheap;
	//RULE 2 : IF service IS good THEN tip IS average; 
	//RULE 3 : IF service IS excellent AND food IS delicious THEN tip IS generous;
	
	
	RULE 1: IF targetDist IS far THEN linearVelocity is fast;
	RULE 2: If targetDist IS middle THEN linearVelocity is medium;
	RULE 3: IF targetDist is close THEN linearVelocity is slow;
	
	RULE 4: IF targetTheta is sideLeft THEN angularVelocity is ML;
	RULE 5: IF targetTheta is straight THEN angularVelocity is zero;
	RULE 6: IF targetTheta is sideRight THEN angularVelocity is MR;
	RULE 7: IF targetTheta is behindLeft THEN angularVelocity is LL;
	RULE 8: IF targetTheta is behindRight THEN angularVelocity is LR;
	RULE 9: IF targetTheta is frontLeft THEN angularVelocity is SL;
	RULE 10: IF targetTheta is frontRight THEN angularVelocity is SR; 
	
	
	
END_RULEBLOCK

END_FUNCTION_BLOCK

